<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TimeLockedBond Deposit</title>
    <link rel="stylesheet" href="styles/fonts.css" />
    <link rel="stylesheet" href="styles/index.css" />
    <link rel="icon" type="image/png" href="styles/logo.png" />
  </head>
  <body>
    <!-- Logo and navigation buttons on same line -->
    <div class="top-nav">
      <button id="connectWallet" class="connect-wallet">Connect</button>
      <img src="styles/logo.png" alt="Logo" class="logo-img" />
      <button class="admin-btn page-direct" id="adminLogin">Admin</button>
    </div>

    <div class="container">
      <h2>Deposit Bond</h2>
      <div id="walletDisplay" class="wallet-display wallet-display-hidden">
        <span id="walletAddress"></span>
      </div>
      <form id="depositForm">
        <label for="depositAmount">Amount in ETH:</label>
        <input
          type="number"
          id="depositAmount"
          placeholder="Amount in ETH"
          min="0.001"
          step="0.001"
          required
        />
        <label for="lockDuration">Lock Duration:</label>
        <select id="lockDuration" required>
          <option value="">Select duration</option>
          <option value="120">2 minutes (for testing)</option>
          <option value="7776000">3 months</option>
          <option value="15552000">6 months</option>
          <option value="23328000">9 months</option>
          <option value="31536000">12 months (1 year)</option>
        </select>
        <button type="submit">Deposit</button>
      </form>
      <div id="status" style="display: none;"></div>
    </div>
    <div class="container" id="depositStatusContainer">
      <h3>Your Bond Status</h3>
      <div id="depositStatus">
        Please connect your wallet to view your bond status.
      </div>
      
      <!-- Action buttons section -->
      <div id="actionButtons" style="display: none;">
        <button id="withdrawBtn" style="display: none;">üí∞ Withdraw</button>
        <button id="refreshStatusBtn" style="display: none;">üîÑ Refresh Status</button>
        <button id="forceRefreshBtn" style="display: none;">‚ö° Force Blockchain Update</button>
      </div>
      
      <button id="refreshTimeBtn" style="display: none;">üîÑ Refresh Blockchain Time</button>
      <div id="withdrawStatus" style="display: none;"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script>
      let account;
      
      // Helper function to show/hide status div based on content
      function setStatus(content, isHTML = false) {
        const statusDiv = document.getElementById('status');
        if (content && content.trim() !== '') {
          if (isHTML) {
            statusDiv.innerHTML = content;
          } else {
            statusDiv.innerText = content;
          }
          statusDiv.style.display = 'block';
        } else {
          statusDiv.innerHTML = '';
          statusDiv.style.display = 'none';
        }
      }

      function clearWithdrawStatus() {
        setWithdrawStatus('');
      }

      function setBondStatusMessage(content) {
        const bondStatusDiv = document.getElementById('depositStatus');
        if (content && content.trim() !== '') {
          bondStatusDiv.innerHTML = `<p style="color: var(--primary-blue); font-weight: 600;">${content}</p>`;
        }
      }

      function setWithdrawStatus(content, isHTML = false, showConfetti = false) {
        const statusDiv = document.getElementById('withdrawStatus');
        if (content && content.trim() !== '') {
          if (isHTML) {
            statusDiv.innerHTML = content;
          } else {
            statusDiv.innerText = content;
          }
          statusDiv.style.display = 'block';
          
          if (showConfetti) {
            createConfetti();
          }
        } else {
          statusDiv.innerHTML = '';
          statusDiv.style.display = 'none';
        }
      }

      function createConfetti() {
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd', '#98d8c8'];
        const confettiCount = 50;
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.className = 'confetti';
          confetti.style.cssText = `
            position: fixed;
            width: 10px;
            height: 10px;
            background: ${colors[Math.floor(Math.random() * colors.length)]};
            left: ${Math.random() * 100}vw;
            top: -10px;
            opacity: 1;
            transform: rotate(${Math.random() * 360}deg);
            z-index: 10000;
            pointer-events: none;
            animation: confetti-fall ${Math.random() * 3 + 2}s linear forwards;
          `;
          document.body.appendChild(confetti);
          
          setTimeout(() => {
            if (confetti.parentNode) {
              confetti.parentNode.removeChild(confetti);
            }
          }, 5000);
        }
      }
      
      window.addEventListener("DOMContentLoaded", async () => {
        account = undefined;
        
        // Check for stored wallet connection
        const storedWallet = localStorage.getItem('connectedWallet');
        if (storedWallet && window.ethereum) {
          try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.includes(storedWallet)) {
              account = storedWallet;
              document.getElementById("walletAddress").innerText = `Connected: ${account}`;
              document.getElementById("walletDisplay").classList.remove('wallet-display-hidden');
              setStatus(""); // Clear status when connected
              updateDepositStatus();
              updateWalletButton();
              return;
            } else {
              // Stored wallet is no longer connected, clear it
              localStorage.removeItem('connectedWallet');
            }
          } catch (err) {
            console.log('Error checking stored wallet:', err);
            localStorage.removeItem('connectedWallet');
          }
        }
        
        document.getElementById("walletDisplay").classList.add('wallet-display-hidden');
        setStatus("Wallet disconnected.");
        const adminLoginBtn = document.getElementById("adminLogin");
        if (adminLoginBtn) {
          adminLoginBtn.style.display = "none"; // Hide admin button by default
        }
        updateDepositStatus();
        updateWalletButton();
      });
              // Contract address and ABI
        const contractAddress = '0x1693E3550A169234CfA7190ACB5E0ffE27697917';
      const contractABI = [
        {
          inputs: [
            { internalType: "address", name: "_initialOwner", type: "address" },
          ],
          stateMutability: "nonpayable",
          type: "constructor",
        },
        {
          inputs: [{ internalType: "address", name: "owner", type: "address" }],
          name: "OwnableInvalidOwner",
          type: "error",
        },
        {
          inputs: [
            { internalType: "address", name: "account", type: "address" },
          ],
          name: "OwnableUnauthorizedAccount",
          type: "error",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "depositor",
              type: "address",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "remaining",
              type: "uint256",
            },
          ],
          name: "Deducted",
          type: "event",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "depositor",
              type: "address",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "releaseTime",
              type: "uint256",
            },
          ],
          name: "Deposited",
          type: "event",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "previousOwner",
              type: "address",
            },
            {
              indexed: true,
              internalType: "address",
              name: "newOwner",
              type: "address",
            },
          ],
          name: "OwnershipTransferred",
          type: "event",
        },
        {
          anonymous: false,
          inputs: [
            {
              indexed: true,
              internalType: "address",
              name: "depositor",
              type: "address",
            },
            {
              indexed: false,
              internalType: "uint256",
              name: "amount",
              type: "uint256",
            },
          ],
          name: "Withdrawn",
          type: "event",
        },
        {
          inputs: [],
          name: "DURATION",
          outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [
            { internalType: "address", name: "_depositor", type: "address" },
            { internalType: "uint256", name: "_amount", type: "uint256" },
          ],
          name: "deductETH",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "depositETH",
          outputs: [],
          stateMutability: "payable",
          type: "function",
        },
        {
          inputs: [
            { internalType: "address", name: "_depositor", type: "address" },
          ],
          name: "getDepositInfo",
          outputs: [
            { internalType: "uint256", name: "amount", type: "uint256" },
            { internalType: "uint256", name: "releaseTime", type: "uint256" },
            { internalType: "uint256", name: "deductedAmount", type: "uint256" },
            { internalType: "uint256", name: "availableAmount", type: "uint256" },
            { internalType: "bool", name: "isWithdrawable", type: "bool" },
          ],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [
            { internalType: "address", name: "_depositor", type: "address" },
          ],
          name: "hasDeposit",
          outputs: [{ internalType: "bool", name: "", type: "bool" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "owner",
          outputs: [{ internalType: "address", name: "", type: "address" }],
          stateMutability: "view",
          type: "function",
        },
        {
          inputs: [],
          name: "renounceOwnership",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [
            { internalType: "address", name: "newOwner", type: "address" },
          ],
          name: "transferOwnership",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
        {
          inputs: [],
          name: "withdrawETH",
          outputs: [],
          stateMutability: "nonpayable",
          type: "function",
        },
      ];

      async function updateDepositStatus(withdrawn = false) {
        const withdrawBtn = document.getElementById("withdrawBtn");
        const refreshTimeBtn = document.getElementById("refreshTimeBtn");
        const forceRefreshBtn = document.getElementById("forceRefreshBtn");
        const refreshStatusBtn = document.getElementById("refreshStatusBtn");
        const actionButtons = document.getElementById("actionButtons");
        const adminBtn = document.getElementById("adminLogin");
        
        if (!account) {
          document.getElementById("depositStatus").innerHTML =
            "Please connect your wallet to view your bond status.";
          actionButtons.style.display = "none";
          refreshTimeBtn.style.display = "none";
          if (adminBtn) {
            adminBtn.style.display = "none"; // Hide admin button when no wallet connected
          }
          return;
        }
        
        try {
          const provider = new ethers.providers.Web3Provider(
            window.ethereum,
            "any"
          );
          const contract = new ethers.Contract(
            contractAddress,
            contractABI,
            provider
          );
          
          // Check if connected account is the contract owner
          const owner = await contract.owner();
          if (account.toLowerCase() === owner.toLowerCase()) {
            adminBtn.style.display = "block"; // Show admin button for owner
          } else {
            adminBtn.style.display = "none"; // Hide admin button for non-owners
          }

          // Check if deposit exists
          const hasDeposit = await contract.hasDeposit(account);
          if (!hasDeposit) {
            document.getElementById("depositStatus").innerHTML = `
              <p><strong>Status:</strong> ‚ùå No deposit found</p>
              <p>You don't have any active bonds. Make a deposit to get started!</p>
            `;
            withdrawBtn.style.display = "none";
            refreshTimeBtn.style.display = "none";
            forceRefreshBtn.style.display = "none";
            return;
          }

          // Get detailed deposit info
          // First check the blockchain time for accurate debugging
          const block = await provider.getBlock('latest');
          const blockTimestamp = block.timestamp;
          
          console.log('=== BLOCKCHAIN TIME DEBUG ===');
          console.log('Block timestamp:', blockTimestamp, new Date(blockTimestamp * 1000));
          console.log('Frontend time:', Math.floor(Date.now() / 1000), new Date());
          console.log('Time difference (block - frontend):', blockTimestamp - Math.floor(Date.now() / 1000), 'seconds');
          console.log('=== END BLOCKCHAIN TIME DEBUG ===');
          
          const bondData = await contract.getDepositInfo(account);
          const [amount, releaseTime, deductedAmount, availableAmount, isWithdrawable] = bondData;
          
          const ethAmount = ethers.utils.formatEther(amount);
          const ethDeducted = ethers.utils.formatEther(deductedAmount);
          const ethAvailable = ethers.utils.formatEther(availableAmount);
          
          // Get current time for calculations and debugging
          const currentTime = Math.floor(Date.now() / 1000);
          
          // Enhanced debugging for withdrawal issues
          console.log('=== WITHDRAWAL DEBUGGING ===');
          console.log('Contract Data:');
          console.log('- Amount:', amount.toString(), 'ETH:', ethAmount);
          console.log('- Release Time:', releaseTime.toString(), new Date(releaseTime * 1000));
          console.log('- Deducted Amount:', deductedAmount.toString(), 'ETH:', ethDeducted);
          console.log('- Available Amount:', availableAmount.toString(), 'ETH:', ethAvailable);
          console.log('- Is Withdrawable (contract):', isWithdrawable);
          
          console.log('Time Analysis:');
          console.log('- Current time (frontend):', currentTime, new Date(currentTime * 1000));
          console.log('- Block time (blockchain):', blockTimestamp, new Date(blockTimestamp * 1000));
          console.log('- Release time:', releaseTime.toString(), new Date(releaseTime * 1000));
          console.log('- Time difference (frontend):', currentTime - releaseTime, 'seconds');
          console.log('- Time difference (blockchain):', blockTimestamp - releaseTime, 'seconds');
          console.log('- Frontend thinks expired:', currentTime >= releaseTime);
          console.log('- Blockchain thinks expired:', blockTimestamp >= releaseTime);
          console.log('- Blockchain lag (blockchain behind frontend):', blockTimestamp - currentTime, 'seconds');
          
          // Calculate what should be available
          const shouldBeAvailable = parseFloat(ethAmount) - parseFloat(ethDeducted);
          console.log('Expected available amount:', shouldBeAvailable, 'ETH');
          console.log('Contract says available:', ethAvailable, 'ETH');
          console.log('=== END DEBUGGING ===');
          
          const releaseDate = formatDate(releaseTime);
          // Use blockchain time for accurate calculations
          const isExpired = blockTimestamp >= releaseTime;
          const isExpiredByLocalTime = currentTime >= releaseTime;
          
          // Calculate blockchain lag
          const blockchainLag = blockTimestamp - currentTime;
          const blockchainLagMinutes = Math.abs(Math.floor(blockchainLag / 60));
          const blockchainLagSeconds = Math.abs(blockchainLag % 60);
          
          let statusText = withdrawn ? "üéâ Withdraw completed!" :
            isExpired ? 
              (isWithdrawable ? "‚úÖ Ready for withdrawal" : "‚ö†Ô∏è Expired but no funds available") : 
              "üîí Still locked";

        // Always show action buttons section when connected and have deposit info
        actionButtons.style.display = "block";
        refreshStatusBtn.style.display = "block";
        document.getElementById("depositStatus").innerHTML = `
          <p><strong>Address:</strong> ${account}</p>
          <p><strong>Status:</strong> ${statusText}</p>
          <p><strong>Original Deposit:</strong> ${ethAmount} ETH</p>
          <p><strong>Deducted Amount:</strong> ${ethDeducted} ETH</p>
          <p><strong>Available for Withdrawal Upon Release:</strong> ${ethAvailable} ETH</p>
          <p style="font-size: 0.75rem; color: var(--text-light); margin-top: -8px;"><em>(Refresh status after release time to view)</em></p>
          <p><strong>Release Date:</strong> ${releaseDate}</p>
        `;
        
        // Always show action buttons section when connected and have deposit info
        actionButtons.style.display = "block";
        refreshStatusBtn.style.display = "block";
        
        // Show withdraw button if funds are unlocked and available
        if (isWithdrawable && parseFloat(ethAvailable) > 0 && !withdrawn) {
          withdrawBtn.style.display = "block";
        } else {
          withdrawBtn.style.display = "none";
        }
        
        // Hide all other buttons - only use Refresh Status and Withdraw
        refreshTimeBtn.style.display = "none";
        forceRefreshBtn.style.display = "none";
        } catch (err) {
          // Show action buttons even when no deposit (for refresh functionality)
          actionButtons.style.display = "block";
          refreshStatusBtn.style.display = "block";
          withdrawBtn.style.display = "none";
          refreshTimeBtn.style.display = "none";
          forceRefreshBtn.style.display = "none";
          
          // Detect 'No deposit found' error
          if (err.message && err.message.includes("No deposit found")) {
            document.getElementById("depositStatus").innerHTML = `
              <p><strong>Status:</strong> ‚ùå No deposit found</p>
              <p>You don't have any active bonds. Make a deposit to get started!</p>
            `;
          } else {
            document.getElementById("depositStatus").innerHTML = `
              <p><strong>Status:</strong> ‚ùå Error fetching deposit info</p>
              <p>Error: ${err.message}</p>
            `;
          }
        }
      }
      document.getElementById("withdrawBtn").onclick = async () => {
        if (!account) return;
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          const contract = new ethers.Contract(
            contractAddress,
            contractABI,
            signer
          );
          const tx = await contract.withdrawETH({
            gasLimit: 150000, // Set a reasonable gas limit for withdraw
            gasPrice: ethers.utils.parseUnits('20', 'gwei') // Set gas price for Sepolia
          });
          setWithdrawStatus("Withdraw transaction sent! Waiting for confirmation...");
          const receipt = await tx.wait();
          
          // Check if we're on Sepolia network and show Etherscan link
          const network = await provider.getNetwork();
          if (network.chainId === 11155111) { // Sepolia chainId
            const etherscanUrl = `https://sepolia.etherscan.io/tx/${tx.hash}`;
            setWithdrawStatus(`üéâ Withdraw successful!<br><a href="${etherscanUrl}" target="_blank" class="etherscan-link">View on Sepolia Etherscan</a>`, true, true);
          } else {
            setWithdrawStatus("üéâ Withdraw successful!", false, true);
          }
          updateDepositStatus(true);
        } catch (err) {
          setWithdrawStatus(err.message);
        }
      };

      // Global variables for countdown timer
      let countdownInterval;
      let lastBlockTimestamp;
      let releaseTimestamp;
      let blockTimeFetched; // When we fetched the last block timestamp
      let globalProvider; // Store provider for blockchain time updates

      // Function to update countdown display
      function updateCountdown() {
        if (!lastBlockTimestamp || !releaseTimestamp || !blockTimeFetched) return;
        
        // Estimate current blockchain time (last known + elapsed time since we fetched it)
        const now = Math.floor(Date.now() / 1000);
        const timeSinceFetch = now - blockTimeFetched;
        const estimatedBlockTime = lastBlockTimestamp + timeSinceFetch;
        
        const timeLeftBlockchain = releaseTimestamp - estimatedBlockTime;
        const timeLeftLocal = releaseTimestamp - now;
        
        if (timeLeftBlockchain <= 0) {
          // Time expired, trigger a refresh to check withdrawal status
          clearCountdownTimer();
          const countdownElement = document.getElementById('countdownDisplay');
          if (countdownElement) {
            countdownElement.innerHTML = `
              <p><strong>üéâ Time Expired!</strong> Checking withdrawal status...</p>
              <p style="font-size: 0.9em; color: var(--text-light);"><em>Refreshing bond status...</em></p>
            `;
          }
          // Refresh the bond status after a short delay
          setTimeout(() => updateDepositStatus(false), 2000);
          return;
        }
        
        const daysB = Math.floor(timeLeftBlockchain / 86400);
        const hoursB = Math.floor((timeLeftBlockchain % 86400) / 3600);
        const minutesB = Math.floor((timeLeftBlockchain % 3600) / 60);
        const secondsB = timeLeftBlockchain % 60;
        
        // Update the countdown display
        const countdownElement = document.getElementById('countdownDisplay');
        if (countdownElement) {
          if (timeLeftLocal <= 0) {
            // Local time expired, show special message
            countdownElement.innerHTML = `
              <p style="color: var(--text-warning);"><strong>‚è∞ Time Sync Issue:</strong></p>
              <p><strong>Local Time:</strong> EXPIRED ‚úÖ</p>
              <p><strong>Blockchain Time:</strong> ${daysB} days, ${hoursB} hours, ${minutesB} minutes, ${secondsB} seconds remaining</p>
              <p style="font-size: 0.85em; color: var(--text-light);"><em>Live countdown ‚Ä¢ Withdrawal available when blockchain catches up</em></p>
            `;
          } else {
            // Both times still counting down
            const daysL = Math.floor(timeLeftLocal / 86400);
            const hoursL = Math.floor((timeLeftLocal % 86400) / 3600);
            const minutesL = Math.floor((timeLeftLocal % 3600) / 60);
            const secondsL = timeLeftLocal % 60;
            
            countdownElement.innerHTML = `
              <p><strong>Time Remaining (Blockchain):</strong> ${daysB} days, ${hoursB} hours, ${minutesB} minutes, ${secondsB} seconds</p>
              <p style="font-size: 0.9em; color: var(--text-medium);"><strong>Time Remaining (Local):</strong> ${daysL} days, ${hoursL} hours, ${minutesL} minutes, ${secondsL} seconds</p>
              <p style="font-size: 0.85em; color: var(--text-light);"><em>Contract uses blockchain time (top) ‚Ä¢ Live countdown</em></p>
            `;
          }
        }
      }

      // Function to start countdown timer
      function startCountdownTimer(blockTimestamp, releaseTime, provider) {
        // Clear any existing timer
        if (countdownInterval) {
          clearInterval(countdownInterval);
        }
        
        lastBlockTimestamp = blockTimestamp;
        releaseTimestamp = releaseTime;
        blockTimeFetched = Math.floor(Date.now() / 1000); // Record when we got this timestamp
        globalProvider = provider; // Store provider for blockchain updates
        
        // Update immediately
        updateCountdown();
        
        // Update every second
        countdownInterval = setInterval(updateCountdown, 1000);
        
        // Also refresh blockchain time every 30 seconds to stay accurate
        const blockRefreshInterval = setInterval(async () => {
          try {
            if (!globalProvider) return;
            const block = await globalProvider.getBlock('latest');
            lastBlockTimestamp = block.timestamp;
            blockTimeFetched = Math.floor(Date.now() / 1000);
            console.log('Refreshed blockchain time:', lastBlockTimestamp, new Date(lastBlockTimestamp * 1000));
          } catch (error) {
            console.log('Failed to refresh blockchain time:', error);
          }
        }, 30000); // Every 30 seconds
        
        // Store the interval ID so we can clear it later
        countdownInterval.blockRefreshInterval = blockRefreshInterval;
        
        console.log('Started countdown timer:', {
          blockTimestamp,
          releaseTime,
          blockTimeFetched,
          timeRemaining: releaseTime - blockTimestamp
        });
      }
      
      // Function to clear all timers
      function clearCountdownTimer() {
        if (countdownInterval) {
          clearInterval(countdownInterval);
          if (countdownInterval.blockRefreshInterval) {
            clearInterval(countdownInterval.blockRefreshInterval);
          }
          countdownInterval = null;
        }
      }

      // Refresh blockchain time button (for local networks)
      document.getElementById("refreshTimeBtn").onclick = async () => {
        if (!account) return;
        clearWithdrawStatus(); // Clear withdraw success message
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const network = await provider.getNetwork();
          
          // Only show this functionality for local networks
          if (network.chainId === 31337 || network.chainId === 1337) { // Hardhat local network
            const signer = provider.getSigner();
            setBondStatusMessage("üîÑ Refreshing blockchain time...");
            
            // Send a tiny transaction to mine a new block and update blockchain time
            const tx = await signer.sendTransaction({
              to: account, // Send to self
              value: 0,    // No value transfer
              gasLimit: 21000, // Standard gas limit for simple transfer
              gasPrice: ethers.utils.parseUnits('20', 'gwei')
            });
            
            await tx.wait();
            setBondStatusMessage("‚úÖ Blockchain time refreshed! Updating bond status...");
            
            // Update the deposit status after the blockchain time refresh
            setTimeout(() => {
              updateDepositStatus();
            }, 1000);
          } else {
            setBondStatusMessage("‚ö†Ô∏è Time refresh only available on local networks");
            setTimeout(() => updateDepositStatus(), 3000);
          }
        } catch (err) {
          setBondStatusMessage(`‚ùå Error refreshing time: ${err.message}`);
          setTimeout(() => updateDepositStatus(), 3000);
        }
      };

      function updateWalletButton() {
        const btn = document.getElementById("connectWallet");
        btn.classList.add("connectWallet"); // Apply the CSS class for alignment
        
        const adminBtn = document.getElementById("adminLogin");
        
        if (account) {
          btn.textContent = "Disconnect";
          btn.style.background = "#dc3545";
          btn.onclick = () => {
            account = undefined;
            localStorage.removeItem('connectedWallet'); // Clear stored connection
            document.getElementById("walletDisplay").classList.add('wallet-display-hidden');
            setStatus("Wallet disconnected.");
            clearWithdrawStatus(); // Clear withdraw success message
            if (adminBtn) {
              adminBtn.style.display = "none"; // Hide admin button on disconnect
            }
            updateDepositStatus();
            updateWalletButton();
          };
        } else {
          btn.textContent = "Connect";
          btn.style.background = "";
          adminBtn.style.display = "none"; // Hide admin button when not connected
          btn.onclick = async () => {
            if (window.ethereum && window.ethereum.isMetaMask) {
              try {
                const accounts = await window.ethereum.request({
                  method: "eth_requestAccounts",
                });
                account = accounts[0];
                localStorage.setItem('connectedWallet', account); // Store connection
                document.getElementById("walletAddress").innerText = `Connected: ${account}`;
                document.getElementById("walletDisplay").classList.remove('wallet-display-hidden');
                setStatus(""); // Clear status when connected
                updateDepositStatus();
                updateWalletButton();
              } catch (err) {
                if (err.code === 4001) {
                  document.getElementById("status").innerText =
                    "Connection request rejected by user.";
                } else {
                  document.getElementById("status").innerText = err.message;
                }
              }
            } else {
              alert(
                "MetaMask not detected! Please install MetaMask to use this site."
              );
            }
          };
        }
      }

      document.getElementById("depositForm").onsubmit = async (e) => {
        e.preventDefault();
        clearWithdrawStatus(); // Clear withdraw success message when making new deposit
        
        if (!account) {
          alert("Please connect your wallet first!");
          return;
        }
        const amount = document.getElementById("depositAmount").value;
        const duration = document.getElementById("lockDuration").value;
        
        if (amount < 0.001) {
          alert("Please enter a valid amount (minimum 0.001 ETH)");
          return;
        }
        
        if (!duration) {
          alert("Please select a lock duration");
          return;
        }
        
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          const contract = new ethers.Contract(
            contractAddress,
            contractABI,
            signer
          );
          
          // Note: This assumes the contract has a depositETH function that accepts duration
          // If your contract doesn't support custom duration, you'll need to modify the contract
          const tx = await contract.depositETH({
            value: ethers.utils.parseEther(amount),
            gasLimit: 200000, // Set a reasonable gas limit
            gasPrice: ethers.utils.parseUnits('20', 'gwei') // Set gas price for Sepolia
          });
          
          setStatus("Transaction sent! Waiting for confirmation...");
          const receipt = await tx.wait();
          
          // Check if we're on Sepolia network and show Etherscan link
          const network = await provider.getNetwork();
          if (network.chainId === 11155111) { // Sepolia chainId
            const etherscanUrl = `https://sepolia.etherscan.io/tx/${tx.hash}`;
            setStatus(`‚úÖ Deposit successful!<br><strong>Transaction Hash:</strong> ${tx.hash}<br><a href="${etherscanUrl}" target="_blank" class="etherscan-link">View on Sepolia Etherscan</a>`, true);
          } else {
            // For local networks, show transaction hash
            setStatus(`‚úÖ Deposit successful!<br><strong>Transaction Hash:</strong> ${tx.hash}`, true);
          }
          updateDepositStatus();
        } catch (err) {
          setStatus(err.message);
        }
      };

      // Refresh Status button - sends small ETH transaction to trigger blockchain updates
      document.getElementById("refreshStatusBtn")?.addEventListener("click", async () => {
        if (!account) return;

        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);

          // Log the network details for debugging
          const network = await provider.getNetwork();
          console.log("Connected to network:", network);

          // Use MetaMask's provider to fetch the latest block details
          const block = await provider.getBlock("latest");
          const blockTimestamp = block.timestamp;

          console.log("Blockchain time (block timestamp):", blockTimestamp);

          // Check if the release time has passed
          const contract = new ethers.Contract(contractAddress, contractABI, provider);
          const bondData = await contract.getDepositInfo(account);
          const [, releaseTime] = bondData;

          const releaseTimeNumber = releaseTime.toNumber(); // Convert BigNumber to number
          console.log("Release time from contract (as number):", releaseTimeNumber);

          if (blockTimestamp >= releaseTimeNumber) {
            console.log("Time has passed. Showing withdraw button.");
            // Time has passed, show the withdraw button
            const withdrawBtn = document.getElementById("withdrawBtn");
            withdrawBtn.style.display = "block";
          } else {
            console.log("Time has not passed. Hiding withdraw button.");
            // Time has not passed, hide the withdraw button
            const withdrawBtn = document.getElementById("withdrawBtn");
            withdrawBtn.style.display = "none";
          }
        } catch (err) {
          console.error("Error checking blockchain time:", err);
        }
      });

      document.getElementById("adminLogin")?.addEventListener("click", () => {
        clearWithdrawStatus(); // Clear withdraw success message
        // Store current connection state before navigating
        if (account) {
          localStorage.setItem('connectedWallet', account);
        }
        window.location.href = "admin.html";
      });

      // Force blockchain refresh button (for Sepolia time sync issues)
      document.getElementById("forceRefreshBtn")?.addEventListener("click", async () => {
        if (!account) return;
        clearWithdrawStatus();
        try {
          const provider = new ethers.providers.Web3Provider(window.ethereum);
          const signer = provider.getSigner();
          setBondStatusMessage("‚ö° Forcing blockchain update...");
          
          // Check current balance to make sure we have enough for a tiny transaction
          const balance = await signer.getBalance();
          if (balance.lt(ethers.utils.parseEther("0.001"))) {
            setBondStatusMessage("‚ùå Insufficient balance for blockchain update transaction");
            return;
          }
          
          // Send a tiny transaction to trigger a new block
          const tx = await signer.sendTransaction({
            to: account, // Send to self
            value: ethers.utils.parseEther("0.0001"), // Very small amount
            gasLimit: 21000,
            gasPrice: ethers.utils.parseUnits('20', 'gwei')
          });
          
          setBondStatusMessage("‚è≥ Mining new block...");
          await tx.wait();
          
          setBondStatusMessage("‚úÖ Blockchain updated! Refreshing status...");
          
          // Wait a moment then refresh the deposit status
          setTimeout(() => {
            updateDepositStatus(false);
          }, 2000);
          
        } catch (err) {
          setBondStatusMessage(`‚ùå Failed to force blockchain update: ${err.message}`);
        }
      });

      // Helper function to format timestamp to readable date
      function formatDate(timestamp) {
        return new Date(timestamp * 1000).toLocaleString();
      }

      // Add a note under the refresh status button
      const refreshStatusNote = document.createElement("p");
      refreshStatusNote.textContent = "Tip: Click on your wallet extension to update the blockchain time.";
      refreshStatusNote.style.fontSize = "0.85rem";
      refreshStatusNote.style.color = "var(--text-light)";
      refreshStatusNote.style.marginTop = "8px";
      refreshStatusNote.style.textAlign = "center";

      const refreshStatusBtn = document.getElementById("refreshStatusBtn");
      if (refreshStatusBtn && refreshStatusBtn.parentNode) {
        refreshStatusBtn.parentNode.insertBefore(refreshStatusNote, refreshStatusBtn.nextSibling);
      }
    </script>
  </body>
</html>
